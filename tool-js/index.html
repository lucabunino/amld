<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>p5.js with Tweakpane</title>
  <script src="https://cdn.jsdelivr.net/npm/p5"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweakpane"></script>
</head>
<body>
<script type="module">
  import {Pane} from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';
  // Setup Tweakpane
  const pane = new Tweakpane();
</script>
<script>
// Parameter configuration
const PARAMS = {
  duration: 5,
  quality: 100,
  canvasWidth: 600,
  canvasHeight: 400,
  format: 'webm',
  timeline: 0,
  columns: [
    { lineCount: 50, speed: 2.5, thickness: 1, animationType: 'verticalBouncing' },
    { lineCount: 70, speed: 3.0, thickness: 2, animationType: 'verticalBouncing' },
    { lineCount: 10, speed: 1.0, thickness: 1, animationType: 'verticalContinuous' },
    { lineCount: 100, speed: 2.5, thickness: 1, animationType: 'backAndForth' },
    { lineCount: 10, speed: 1.0, thickness: 1, animationType: 'verticalBouncing' },
  ],
};

let currentLine = Array(PARAMS.columns.length).fill(0);
let direction = Array(PARAMS.columns.length).fill(1);
let increment = Array(PARAMS.columns.length).fill(0);
let frameCounter = 0;
let animationRunning = true;
let isRendering = false;
let startTime = null;
const framerate = 60;
let p5Instance;

// p5.js setup and draw functions
function sketch(p) {
  p.setup = () => {
    p.createCanvas(PARAMS.canvasWidth, PARAMS.canvasHeight);
    p.frameRate(framerate);
    p.background(0);
    startTime = p.millis();
    requestAnimationFrame(() => animate(p));
  };

  function animate(p) {
    p.background(0);
    const columnWidth = p.width / PARAMS.columns.length;
    const maxFrames = framerate * PARAMS.duration;
    PARAMS.timeline = (p.millis() - startTime) / 1000;

    // Update increment values for each column
    PARAMS.columns.forEach((col, i) => {
      increment[i] = (col.lineCount / (maxFrames / 2)) * col.speed;
    });

    // Animation logic for each column
    PARAMS.columns.forEach((col, i) => {
      const spacing = p.height / col.lineCount;
      p.stroke(255);
      p.strokeWeight(col.thickness).strokeCap(p.SQUARE);

      // Different animation types
      if (col.animationType === 'backAndForth') {
        currentLine[i] += increment[i] * direction[i];
        if (currentLine[i] >= col.lineCount - 1 || currentLine[i] <= 0) {
          direction[i] *= -1;
        }
        for (let j = 0; j <= Math.floor(currentLine[i]); j++) {
          p.line(i * columnWidth, spacing * j, (i + 1) * columnWidth, spacing * j);
        }
      }
      // Additional animation types here...
    });

    if (animationRunning) requestAnimationFrame(() => animate(p));
  }
}

// Create p5 instance
p5Instance = new p5(sketch);

// Setup Tweakpane
const pane = new Tweakpane();

const tab = pane.addTab({
  pages: [
    { title: 'Settings' },
    { title: 'Columns' },
    { title: 'Advanced' },
  ],
});

tab.pages[0].addInput(PARAMS, 'duration', { min: 1, max: 30, step: 1 });
tab.pages[0].addInput(PARAMS, 'canvasWidth', { min: 100, max: 2000, step: 10 }).on('change', resizeCanvas);
tab.pages[0].addInput(PARAMS, 'canvasHeight', { min: 100, max: 2000, step: 10 }).on('change', resizeCanvas);

// Configure column controls
PARAMS.columns.forEach((col, i) => {
  const columnFolder = tab.pages[1].addFolder({ title: `Column ${i + 1}` });
  columnFolder.addInput(col, 'lineCount', { min: 1, max: 300, step: 1 });
  columnFolder.addInput(col, 'speed', { min: 0.1, max: 5, step: 0.1 });
  columnFolder.addInput(col, 'thickness', { min: 1, max: 5, step: 1 });
  columnFolder.addInput(col, 'animationType', {
    options: {
      'Back and Forth': 'backAndForth',
      'Vertical Bouncing': 'verticalBouncing',
      'Vertical Continuous': 'verticalContinuous',
    },
  });
});

// Resize canvas
function resizeCanvas() {
  p5Instance.resizeCanvas(PARAMS.canvasWidth, PARAMS.canvasHeight);
}
</script>
</body>
</html>